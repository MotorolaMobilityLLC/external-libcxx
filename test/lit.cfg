# -*- Python -*- vim: set ft=python ts=4 sw=4 expandtab tw=79:
# Configuration file for the 'lit' test runner.
import os
import site

site.addsitedir(os.path.dirname(__file__))


class AndroidHostLibcxxTestFormat(LibcxxTestFormat):
    def __init__(self, cxx_under_test, libcxx_src_root, libcxx_obj_root,
                 cxx_template, link_template, timeout):
        self.cxx_under_test = cxx_under_test
        self.libcxx_src_root = libcxx_src_root
        self.libcxx_obj_root = libcxx_obj_root
        self.cxx_template = cxx_template
        self.link_template = link_template
        self.timeout = timeout
        self.use_verify_for_fail = False

    def _compile(self, output_path, source_path, use_verify=False):
        if use_verify:
            raise NotImplementedError(
                'AndroidConfiguration does not support use_verify mode.')
        cxx_args = self.cxx_template.replace('%OUT%', output_path)
        cxx_args = cxx_args.replace('%SOURCE%', source_path)
        cmd = [self.cxx_under_test] + shlex.split(cxx_args)
        out, err, exit_code = lit.util.executeCommand(cmd)
        return cmd, out, err, exit_code

    def _link(self, exec_path, object_path):
        link_args = self.link_template.replace('%OUT%', exec_path)
        link_args = link_args.replace('%SOURCE%', object_path)
        cmd = [self.cxx_under_test] + shlex.split(link_args)
        out, err, exit_code = lit.util.executeCommand(cmd)
        return cmd, out, err, exit_code

    def _run(self, exec_path, lit_config, in_dir=None):
        cmd = [exec_path]
        # We need to use LD_LIBRARY_PATH because the build system's rpath is
        # relative, which won't work since we're running from /tmp. We can
        # either scan `cxx_under_test`/`link_template` to determine whether
        # we're 32-bit or 64-bit, scan testconfig.mk, or just add both
        # directories and let the linker sort it out. I'm choosing the lazy
        # option.
        outdir = os.getenv('ANDROID_HOST_OUT')
        libpath = os.pathsep.join([
            os.path.join(outdir, 'lib'),
            os.path.join(outdir, 'lib64'),
        ])
        out, err, rc = lit.util.executeCommand(
            cmd, cwd=in_dir, env={'LD_LIBRARY_PATH': libpath})
        return self._make_report(cmd, out, err, rc)


class AdbError(RuntimeError):
    def __init__(self, cmd, out, err, exit_code):
        self.cmd = cmd
        self.out = out
        self.err = err
        self.exit_code = exit_code


class AndroidLibcxxTestFormat(AndroidHostLibcxxTestFormat):
    def __init__(self, cxx_under_test, libcxx_src_root, libcxx_obj_root,
                 cxx_template, link_template, device_dir, timeout):
        AndroidHostLibcxxTestFormat.__init__(
            self,
            cxx_under_test,
            libcxx_src_root,
            libcxx_obj_root,
            cxx_template,
            link_template,
            timeout)
        self.device_dir = device_dir

    def _working_directory(self, file_name):
        return os.path.join(self.device_dir, file_name)

    def _wd_path(self, test_name, file_name):
        return os.path.join(self._working_directory(test_name), file_name)

    def _adb_mkdir(self, path):
        cmd = ['adb', 'shell', 'mkdir', path]
        out, err, exit_code = lit.util.executeCommand(cmd)
        if exit_code != 0:
            raise AdbError(cmd, out, err, exit_code)

    def _adb_push(self, src, dst):
        cmd = ['adb', 'push', src, dst]
        out, err, exit_code = lit.util.executeCommand(cmd)
        if exit_code != 0:
            raise AdbError(cmd, out, err, exit_code)

    def _build(self, exec_path, source_path, compile_only=False,
               use_verify=False):
        cmd, report, rc = LibcxxTestFormat._build(
            self, exec_path, source_path, compile_only, use_verify)
        if rc != 0:
            return cmd, report, rc

        try:
            exec_file = os.path.basename(exec_path)

            self._adb_mkdir(self._working_directory(exec_file))
            self._adb_push(exec_path, self._wd_path(exec_file, exec_file))

            # Push any .dat files in the same directory as the source to the
            # working directory.
            src_dir = os.path.dirname(source_path)
            data_files = [f for f in os.listdir(src_dir) if f.endswith('.dat')]
            for data_file in data_files:
                df_path = os.path.join(src_dir, data_file)
                df_dev_path = self._wd_path(exec_file, data_file)
                self._adb_push(df_path, df_dev_path)
            return cmd, report, rc
        except AdbError as ex:
            return self._make_report(ex.cmd, ex.out, ex.err, ex.exit_code)

    def _clean(self, exec_path):
        exec_file = os.path.basename(exec_path)
        cmd = ['adb', 'shell', 'rm', '-rf', self._working_directory(exec_file)]
        lit.util.executeCommand(cmd)
        os.remove(exec_path)

    def _run(self, exec_path, lit_config, in_dir=None):
        exec_file = os.path.basename(exec_path)
        shell_cmd = 'cd {} && {}; echo $?'.format(
            self._working_directory(exec_file),
            self._wd_path(exec_file, exec_file))
        cmd = ['timeout', self.timeout, 'adb', 'shell', shell_cmd]

        # Tests will commonly fail with ETXTBSY. Possibly related to this bug:
        # https://code.google.com/p/android/issues/detail?id=65857. Work around
        # it by just waiting a second and then retrying.
        for _ in range(10):
            out, err, exit_code = lit.util.executeCommand(cmd)
            if exit_code == 0:
                if 'Text file busy' in out:
                    time.sleep(1)
                else:
                    out = out.strip().split('\r\n')
                    status_line = out[-1:][0]
                    out = '\n'.join(out[:-1])
                    exit_code = int(status_line)
                    break
            else:
                err += '\nTimed out after {} seconds'.format(self.timeout)
                break
        return self._make_report(cmd, out, err, exit_code)


def mm(path, android_build_top):
    env = os.environ
    env['ONE_SHOT_MAKEFILE'] = os.path.join(path, 'Android.mk')

    cmd = [
        'make', '-C', android_build_top, '-f', 'build/core/main.mk',
        'all_modules', '-B'
    ]
    return not subprocess.Popen(cmd, stdout=None, stderr=None, env=env).wait()


class AndroidConfiguration(Configuration):
    def __init__(self, lit_config, config):
        super(AndroidConfiguration, self).__init__(lit_config, config)
        self.cxx_under_test = None
        self.build_cmds_dir = None
        self.cxx_template = None
        self.link_template = None

    def configure(self):
        self.configure_src_root()
        self.configure_obj_root()

        self.configure_build_cmds()
        self.configure_cxx()
        self.configure_cxx_template()
        self.configure_link_template()
        self.configure_triple()
        self.configure_features()

    def configure_build_cmds(self):
        os.chdir(self.config.android_root)
        self.build_cmds_dir = os.path.join(self.src_root, 'buildcmds')
        if not mm(self.build_cmds_dir, self.config.android_root):
            raise RuntimeError('Could not generate build commands.')

    def configure_cxx(self):
        cxx_under_test_file = os.path.join(self.build_cmds_dir,
                                           'cxx_under_test')
        self.cxx_under_test = open(cxx_under_test_file).read().strip()

    def configure_cxx_template(self):
        cxx_template_file = os.path.join(self.build_cmds_dir, 'cxx.cmds')
        self.cxx_template = open(cxx_template_file).read().strip()

    def configure_link_template(self):
        link_template_file = os.path.join(self.build_cmds_dir, 'link.cmds')
        self.link_template = open(link_template_file).read().strip()

    def configure_triple(self):
        if 'clang' in self.cxx_under_test:
            triple = self.configure_clang_triple()
        else:
            triple = self.configure_gcc_triple()

        if not triple:
            raise RuntimeError('Could not determine target triple.')
        self.config.target_triple = triple

    def configure_clang_triple(self):
        match = re.search(r'-target\s+(\S+)', self.cxx_template)
        if match:
            return match.group(1)
        return None

    def configure_gcc_triple(self):
        proc = subprocess.Popen([self.cxx_under_test, '-v'],
                                stderr=subprocess.PIPE)
        _, stderr = proc.communicate()
        for line in stderr.split('\n'):
            print 'Checking {}'.format(line)
            match = re.search(r'^Target: (.+)$', line)
            if match:
                return match.group(1)
        return None

    def configure_features(self):
        self.config.available_features.add('long_tests')

    def get_test_format(self):
        mode = self.lit_config.params.get('android_mode', 'device')
        if mode == 'device':
            return AndroidLibcxxTestFormat(
                self.cxx_under_test,
                self.src_root,
                self.obj_root,
                self.cxx_template,
                self.link_template,
                getattr(self.config, 'device_dir', '/data/local/tmp/'),
                getattr(self.config, 'timeout', '60'))
        elif mode == 'host':
            return AndroidHostLibcxxTestFormat(
                self.cxx_under_test,
                self.src_root,
                self.obj_root,
                self.cxx_template,
                self.link_template,
                getattr(self.config, 'timeout', '60'))
        else:
            raise RuntimeError('Invalid android_mode: {}'.format(mode))


# Tell pylint that we know config and lit_config exist somewhere.
if 'PYLINT_IMPORT' in os.environ:
    config = object()
    lit_config = object()

# name: The name of this test suite.
config.name = 'libc++'

# suffixes: A list of file extensions to treat as test files.
config.suffixes = ['.cpp']

# test_source_root: The root path where tests are located.
config.test_source_root = os.path.dirname(__file__)

# Infer the test_exec_root from the libcxx_object root.
libcxx_obj_root = getattr(config, 'libcxx_obj_root', None)
if libcxx_obj_root is not None:
    config.test_exec_root = os.path.join(libcxx_obj_root, 'test')

# Check that the test exec root is known.
if config.test_exec_root is None:
    # Otherwise, we haven't loaded the site specific configuration (the user is
    # probably trying to run on a test file directly, and either the site
    # configuration hasn't been created by the build system, or we are in an
    # out-of-tree build situation).
    site_cfg = lit_config.params.get('libcxx_site_config',
                                     os.environ.get('LIBCXX_SITE_CONFIG'))
    if not site_cfg:
        lit_config.warning('No site specific configuration file found!'
                           ' Running the tests in the default configuration.')
        # TODO: Set test_exec_root to a temporary directory where output files
        # can be placed. This is needed for ShTest.
    elif not os.path.isfile(site_cfg):
        lit_config.fatal(
            "Specified site configuration file does not exist: '%s'" %
            site_cfg)
    else:
        lit_config.note('using site specific configuration at %s' % site_cfg)
        lit_config.load_config(config, site_cfg)
        raise SystemExit()

cfg_variant = getattr(config, 'configuration_variant', 'libcxx')
if cfg_variant:
    print 'Using configuration variant: %s' % cfg_variant

# Load the Configuration class from the module name <cfg_variant>.test.config.
config_module_name = '.'.join([cfg_variant, 'test', 'config'])
config_module = __import__(config_module_name, fromlist=['Configuration'])

configuration = config_module.Configuration(lit_config, config)
configuration.configure()
config.test_format = configuration.get_test_format()
